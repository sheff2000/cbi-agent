// =============================
// File: core/rcBuffer.js
// ПОКА СЫРЫЕ РАЗМЫШЛЕНИЯ на тему КАК ЭТО ПЕРЕДЕЛАТЬ
// =============================
//
// ГЛОБАЛЬНЫЙ ХРАНИЛИЩЕ СОСТОЯНИЯ RC-КАНАЛОВ
//
// единый объект в памяти агента, где:
//   • wsRC-модули кладут последние значения каналов (осей, кнопок) от пилотов;
//   • Serial-модуль берёт оттуда нужный источник и пишет его в UART.
//   • примерная частота пакетов +-50 Гц;
//   • глобальный объект (в памяти) — мгновенный доступ без сериализации;
//   • поддерживает любое количество пилотов, дронов и Serial-портов.
//
// Структура данных (предположительный вид):
//   RCState.sources:    карта всех пультов (pilotId → { channels, seq, ts, active });
//   RCState.serialLinks: карта всех UART-портов (serialId → { port, baud, activeSource });
//
// =============================

// Главный объект состояния RC
export const RCState = {
  // Источники данных (джойстики / пилоты)
  // Ключ: pilotId (строка, например "pilot_1", скорее всего айди)
  // Значение: { channels: [16 чисел], seq: номер пакета, ts: время последнего обновления, active: true|false }
  sources: new Map(),

  // Привязки Serial-портов к конкретным источникам (джойстикам)
  // Ключ: serialId (например "main", "aux", "onboard1")
  // Значение: { port: '/dev/ttyUSB0', baud: 420000, activeSource: 'pilot_1' }
  serialLinks: new Map(),
};


// ==========================================================
// updateSource(pilotId, data)
// Обновляет данные от конкретного пилота.
// Вызывается из wsRC при получении пакета DEVICE_RC.
//
// Аргументы:
//   pilotId — уникальный идентификатор пульта / пилота.
//   data — объект { channels: [...], seq: N }.
//
// Результат:
//   в RCState.sources[pilotId] лежит самый свежий пакет.
// ==========================================================
export function updateSource(pilotId, data) {
  RCState.sources.set(pilotId, {
    ...data,          // копируем поля channels, seq, и всё что пришло
    ts: Date.now(),   // сохраняем время последнего обновления (для failover)
  });
}


// ==========================================================
// setSourceActive(pilotId, active)
// Помечает конкретный источник активным / неактивным.
// Вызывается, например, при получении команды START_SEND_RC или STOP_SEND_RC.
//
// Аргументы:
//   pilotId — строка (например, "pilot_2").
//   active — булево значение: true = использовать источник, false = заморозить.
//
// Эффект:
//   сериал-модуль при обходе RCState увидит, что этот источник больше не активен.
// ==========================================================
export function setSourceActive(pilotId, active) {
  const s = RCState.sources.get(pilotId);
  if (s) s.active = active;
}


// ==========================================================
// linkSerial(serialId, port, baud, activeSource)
// Создаёт или обновляет привязку между UART-портом и конкретным источником RC.
//
// Аргументы:
//   serialId — уникальное имя этого Serial-линка (например, "main" или "relay_2").
//   port — путь к устройству (например, '/dev/ttyUSB0').
//   baud — скорость порта, например 420000.
//   activeSource — идентификатор пилота, чьи данные должен получать этот порт.
//
// Результат:
//   RCState.serialLinks[serialId] = { port, baud, activeSource }
//   Таким образом можно иметь:
//     - один пульт > несколько портов,
//     - несколько пультов > разные порты.
// ==========================================================
export function linkSerial(serialId, port, baud, activeSource) {
  RCState.serialLinks.set(serialId, { port, baud, activeSource });
}


// ==========================================================
// getActiveChannels(serialId)
// Возвращает последние значения каналов, которые нужно послать в Serial.
//
// Аргументы:
//   serialId — идентификатор UART-порта.
//
// Алгоритм:
//   1. Находим конфигурацию этого порта в RCState.serialLinks.
//   2. Берём из неё activeSource (тот пульт, с которого брать данные).
//   3. Возвращаем массив каналов из RCState.sources[activeSource].
//
// Возвращает:
//   [16 чисел] — если источник найден;
//   null — если нет активного источника.
//
// Используется сериал-модулем в цикле отправки (50 Гц).
// ==========================================================
export function getActiveChannels(serialId) {
  const link = RCState.serialLinks.get(serialId);
  if (!link) return null;  // такого Serial-порта не зарегистрировано
  const src = RCState.sources.get(link.activeSource);
  return src?.channels || null;
}
